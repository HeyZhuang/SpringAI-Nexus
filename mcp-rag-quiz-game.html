<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP & RAG çŸ¥è¯†å†’é™©</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 90%;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        h1 {
            text-align: center;
            color: #764ba2;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        #gameCanvas {
            width: 100%;
            height: 400px;
            border: 3px solid #764ba2;
            border-radius: 15px;
            display: block;
            background: white;
            cursor: pointer;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
            font-weight: bold;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-icon {
            font-size: 1.5em;
        }

        .question-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 90%;
            display: none;
            z-index: 1000;
            animation: modalPop 0.3s ease-out;
        }

        @keyframes modalPop {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .question-modal.active {
            display: block;
        }

        .question-text {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .answers {
            display: grid;
            gap: 10px;
        }

        .answer-btn {
            padding: 15px;
            border: 2px solid #667eea;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            text-align: left;
        }

        .answer-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateX(5px);
        }

        .answer-btn.correct {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .answer-btn.wrong {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        .start-screen {
            text-align: center;
            padding: 40px;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: 1.3em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            margin-top: 20px;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .game-over {
            text-align: center;
            padding: 30px;
            display: none;
        }

        .game-over.active {
            display: block;
        }

        .final-score {
            font-size: 2em;
            color: #764ba2;
            margin: 20px 0;
        }

        .knowledge-fact {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            color: #555;
            line-height: 1.6;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
    </style>
</head>
<body>
    <canvas class="particles" id="particlesCanvas"></canvas>

    <div class="game-container">
        <h1>ğŸš€ MCP & RAG çŸ¥è¯†å†’é™©</h1>
        <p class="subtitle">åœ¨æ¸¸æˆä¸­å­¦ä¹ Model Context Protocolå’ŒRetrieval-Augmented Generation!</p>

        <div id="startScreen" class="start-screen">
            <h2>æ¬¢è¿æ¥åˆ°çŸ¥è¯†å†’é™©ä¸–ç•Œï¼</h2>
            <p style="margin: 20px 0; color: #666; line-height: 1.8;">
                æ§åˆ¶ä½ çš„è§’è‰²æ”¶é›†çŸ¥è¯†å®çŸ³ï¼Œæ¯ä¸ªå®çŸ³éƒ½åŒ…å«ä¸€ä¸ªå…³äºMCPæˆ–RAGçš„é—®é¢˜ã€‚<br>
                å›ç­”æ­£ç¡®è·å¾—åˆ†æ•°ï¼Œå›ç­”é”™è¯¯ä¼šå¤±å»ç”Ÿå‘½å€¼ï¼<br>
                ä½¿ç”¨æ–¹å‘é”®æˆ–WASDæ§åˆ¶ç§»åŠ¨
            </p>
            <button class="start-btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
        </div>

        <canvas id="gameCanvas" style="display: none;"></canvas>

        <div class="stats" id="gameStats" style="display: none;">
            <div class="stat-item">
                <span class="stat-icon">ğŸ’</span>
                <span>å¾—åˆ†: <span id="score">0</span></span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">â¤ï¸</span>
                <span>ç”Ÿå‘½: <span id="lives">3</span></span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">ğŸ¯</span>
                <span>æ­£ç¡®ç‡: <span id="accuracy">0</span>%</span>
            </div>
        </div>

        <div id="gameOver" class="game-over">
            <h2>æ¸¸æˆç»“æŸï¼</h2>
            <p class="final-score">æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
            <p>ä½ å·²ç»æˆä¸ºäº†MCPå’ŒRAGçŸ¥è¯†å¤§å¸ˆï¼</p>
            <button class="start-btn" onclick="resetGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="question-modal" id="questionModal">
        <h3 style="color: #764ba2; margin-bottom: 15px;">ğŸ’¡ çŸ¥è¯†æŒ‘æˆ˜</h3>
        <p class="question-text" id="questionText"></p>
        <div class="answers" id="answersContainer"></div>
        <div class="knowledge-fact" id="knowledgeFact" style="display: none;"></div>
    </div>

    <script>
        // æ¸¸æˆé…ç½®
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 740;
        canvas.height = 400;

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 20,
                speed: 5,
                color: '#764ba2'
            },
            gems: [],
            particles: [],
            score: 0,
            lives: 3,
            totalQuestions: 0,
            correctAnswers: 0,
            isPlaying: false,
            keys: {}
        };

        // MCPå’ŒRAGé—®é¢˜åº“
        const questions = [
            {
                question: "MCP (Model Context Protocol) çš„ä¸»è¦ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ",
                answers: [
                    "è®©AIæ¨¡å‹ä¸å¤–éƒ¨å·¥å…·å’Œæ•°æ®æºè¿›è¡Œæ ‡å‡†åŒ–äº¤äº’",
                    "æé«˜æ¨¡å‹çš„è®­ç»ƒé€Ÿåº¦",
                    "å‡å°‘æ¨¡å‹çš„å‚æ•°é‡",
                    "ä¼˜åŒ–æ¨¡å‹çš„å†…å­˜ä½¿ç”¨"
                ],
                correct: 0,
                fact: "MCPæ˜¯Anthropicå¼€å‘çš„å¼€æ”¾åè®®ï¼Œå…è®¸AIåŠ©æ‰‹ä¸å„ç§å¤–éƒ¨ç³»ç»Ÿè¿›è¡Œæ— ç¼é›†æˆï¼Œå¦‚æ•°æ®åº“ã€APIå’Œå¼€å‘å·¥å…·ã€‚"
            },
            {
                question: "RAG (Retrieval-Augmented Generation) æŠ€æœ¯è§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ",
                answers: [
                    "æ¨¡å‹è®­ç»ƒæ—¶é—´è¿‡é•¿",
                    "æ¨¡å‹çŸ¥è¯†çš„æ—¶æ•ˆæ€§å’Œå‡†ç¡®æ€§é—®é¢˜",
                    "æ¨¡å‹ä½“ç§¯è¿‡å¤§",
                    "æ¨¡å‹æ¨ç†é€Ÿåº¦æ…¢"
                ],
                correct: 1,
                fact: "RAGé€šè¿‡æ£€ç´¢å¤–éƒ¨çŸ¥è¯†åº“æ¥å¢å¼ºç”Ÿæˆå†…å®¹çš„å‡†ç¡®æ€§å’Œæ—¶æ•ˆæ€§ï¼Œè®©AIèƒ½å¤Ÿè®¿é—®æœ€æ–°çš„ä¿¡æ¯ã€‚"
            },
            {
                question: "MCPæœåŠ¡å™¨å¯ä»¥æä¾›å“ªäº›ç±»å‹çš„èµ„æºï¼Ÿ",
                answers: [
                    "ä»…æ–‡æœ¬æ•°æ®",
                    "ä»…APIæ¥å£",
                    "å·¥å…·è°ƒç”¨ã€æ•°æ®è®¿é—®å’Œæç¤ºæ¨¡æ¿",
                    "ä»…æ•°æ®åº“è¿æ¥"
                ],
                correct: 2,
                fact: "MCPæœåŠ¡å™¨å¯ä»¥æš´éœ²ä¸‰ç§æ ¸å¿ƒèµ„æºï¼šå·¥å…·ï¼ˆå¯æ‰§è¡Œå‡½æ•°ï¼‰ã€èµ„æºï¼ˆæ•°æ®è®¿é—®ï¼‰å’Œæç¤ºæ¨¡æ¿ã€‚"
            },
            {
                question: "RAGç³»ç»Ÿä¸­çš„å‘é‡æ•°æ®åº“ä¸»è¦ç”¨äºä»€ä¹ˆï¼Ÿ",
                answers: [
                    "å­˜å‚¨åŸå§‹æ–‡æœ¬",
                    "å­˜å‚¨å’Œæ£€ç´¢è¯­ä¹‰ç›¸ä¼¼çš„æ–‡æ¡£ç‰‡æ®µ",
                    "è®­ç»ƒæ¨¡å‹",
                    "ç¼“å­˜æŸ¥è¯¢ç»“æœ"
                ],
                correct: 1,
                fact: "å‘é‡æ•°æ®åº“å°†æ–‡æœ¬è½¬æ¢ä¸ºé«˜ç»´å‘é‡ï¼Œå®ç°åŸºäºè¯­ä¹‰ç›¸ä¼¼åº¦çš„å¿«é€Ÿæ£€ç´¢ã€‚"
            },
            {
                question: "Spring AIä¸­é›†æˆMCPçš„ä¸»è¦ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ",
                answers: [
                    "è‡ªåŠ¨ç”Ÿæˆä»£ç ",
                    "ç®€åŒ–AIåº”ç”¨ä¸å¤–éƒ¨ç³»ç»Ÿçš„é›†æˆ",
                    "æé«˜ä»£ç è¿è¡Œé€Ÿåº¦",
                    "å‡å°‘å†…å­˜å ç”¨"
                ],
                correct: 1,
                fact: "Spring AIçš„MCPé›†æˆè®©Javaå¼€å‘è€…èƒ½å¤Ÿè½»æ¾æ„å»ºå¯æ‰©å±•çš„AIåº”ç”¨ï¼Œæ— ç¼è¿æ¥å„ç§æ•°æ®æºå’ŒæœåŠ¡ã€‚"
            },
            {
                question: "RAGä¸­çš„'æ£€ç´¢'æ­¥éª¤é€šå¸¸ä½¿ç”¨ä»€ä¹ˆæŠ€æœ¯ï¼Ÿ",
                answers: [
                    "å…³é”®è¯åŒ¹é…",
                    "æ­£åˆ™è¡¨è¾¾å¼",
                    "è¯­ä¹‰å‘é‡ç›¸ä¼¼åº¦æœç´¢",
                    "SQLæŸ¥è¯¢"
                ],
                correct: 2,
                fact: "RAGä½¿ç”¨embeddingæŠ€æœ¯å°†æŸ¥è¯¢å’Œæ–‡æ¡£è½¬æ¢ä¸ºå‘é‡ï¼Œé€šè¿‡è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦æ‰¾åˆ°æœ€ç›¸å…³çš„å†…å®¹ã€‚"
            },
            {
                question: "MCPåè®®æ”¯æŒå“ªç§é€šä¿¡æ–¹å¼ï¼Ÿ",
                answers: [
                    "ä»…HTTP",
                    "ä»…WebSocket",
                    "JSON-RPC over stdioæˆ–HTTP",
                    "ä»…gRPC"
                ],
                correct: 2,
                fact: "MCPä½¿ç”¨JSON-RPC 2.0åè®®ï¼Œå¯ä»¥é€šè¿‡stdioï¼ˆæ ‡å‡†è¾“å…¥è¾“å‡ºï¼‰æˆ–HTTPè¿›è¡Œé€šä¿¡ã€‚"
            },
            {
                question: "åœ¨RAGç³»ç»Ÿä¸­ï¼Œchunkï¼ˆåˆ†å—ï¼‰çš„ç›®çš„æ˜¯ä»€ä¹ˆï¼Ÿ",
                answers: [
                    "å‹ç¼©æ•°æ®",
                    "å°†é•¿æ–‡æ¡£åˆ†å‰²æˆé€‚åˆæ£€ç´¢çš„å°ç‰‡æ®µ",
                    "åŠ å¯†æ•°æ®",
                    "æ ¼å¼åŒ–è¾“å‡º"
                ],
                correct: 1,
                fact: "åˆ†å—ç¡®ä¿æ£€ç´¢åˆ°çš„å†…å®¹æ—¢åŒ…å«è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ï¼Œåˆä¸ä¼šè¶…å‡ºæ¨¡å‹çš„tokené™åˆ¶ã€‚"
            },
            {
                question: "MCPå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„ä¼šè¯æ˜¯å¦‚ä½•å»ºç«‹çš„ï¼Ÿ",
                answers: [
                    "é€šè¿‡OAuthè®¤è¯",
                    "é€šè¿‡åˆå§‹åŒ–æ¡æ‰‹å’Œèƒ½åŠ›åå•†",
                    "é€šè¿‡APIå¯†é’¥",
                    "é€šè¿‡ç”¨æˆ·åå¯†ç "
                ],
                correct: 1,
                fact: "MCPä½¿ç”¨initializeè¯·æ±‚è¿›è¡Œæ¡æ‰‹ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨äº¤æ¢å„è‡ªæ”¯æŒçš„èƒ½åŠ›ã€‚"
            },
            {
                question: "RAGç›¸æ¯”fine-tuningï¼ˆå¾®è°ƒï¼‰çš„ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ",
                answers: [
                    "è®¡ç®—æˆæœ¬æ›´ä½ï¼ŒçŸ¥è¯†æ›´æ–°æ›´çµæ´»",
                    "æ¨¡å‹æ€§èƒ½æ›´å¥½",
                    "æ¨ç†é€Ÿåº¦æ›´å¿«",
                    "æ¨¡å‹ä½“ç§¯æ›´å°"
                ],
                correct: 0,
                fact: "RAGæ— éœ€é‡æ–°è®­ç»ƒæ¨¡å‹å³å¯æ›´æ–°çŸ¥è¯†ï¼Œè€Œå¾®è°ƒéœ€è¦å¤§é‡è®¡ç®—èµ„æºå’Œæ—¶é—´ã€‚"
            }
        ];

        // å®çŸ³ç±»
        class Gem {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 15;
                this.color = `hsl(${Math.random() * 60 + 180}, 70%, 60%)`;
                this.rotation = 0;
                this.collected = false;
                this.question = questions[Math.floor(Math.random() * questions.length)];
            }

            update() {
                this.rotation += 0.05;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // ç»˜åˆ¶å…­è¾¹å½¢å®çŸ³
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = this.size * Math.cos(angle);
                    const y = this.size * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();

                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }
        }

        // ç²’å­ç±»
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.size = Math.random() * 5 + 2;
                this.color = color;
                this.life = 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.size *= 0.98;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // åˆ›å»ºå®çŸ³
        function createGem() {
            const margin = 50;
            const x = Math.random() * (canvas.width - margin * 2) + margin;
            const y = Math.random() * (canvas.height - margin * 2) + margin;
            gameState.gems.push(new Gem(x, y));
        }

        // åˆ›å»ºç²’å­æ•ˆæœ
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push(new Particle(x, y, color));
            }
        }

        // æ£€æŸ¥ç¢°æ’
        function checkCollision(obj1, obj2, dist) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy) < dist;
        }

        // æ˜¾ç¤ºé—®é¢˜
        function showQuestion(gem) {
            const modal = document.getElementById('questionModal');
            const overlay = document.getElementById('overlay');
            const questionText = document.getElementById('questionText');
            const answersContainer = document.getElementById('answersContainer');
            const knowledgeFact = document.getElementById('knowledgeFact');

            questionText.textContent = gem.question.question;
            answersContainer.innerHTML = '';
            knowledgeFact.style.display = 'none';

            gem.question.answers.forEach((answer, index) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = answer;
                btn.onclick = () => {
                    // ç¦ç”¨æ‰€æœ‰æŒ‰é’®
                    const allBtns = answersContainer.querySelectorAll('.answer-btn');
                    allBtns.forEach(b => b.style.pointerEvents = 'none');

                    if (index === gem.question.correct) {
                        btn.classList.add('correct');
                        gameState.score += 100;
                        gameState.correctAnswers++;
                        createParticles(gameState.player.x, gameState.player.y, '#4caf50', 20);
                    } else {
                        btn.classList.add('wrong');
                        allBtns[gem.question.correct].classList.add('correct');
                        gameState.lives--;
                        createParticles(gameState.player.x, gameState.player.y, '#f44336', 20);
                    }

                    gameState.totalQuestions++;
                    updateStats();

                    // æ˜¾ç¤ºçŸ¥è¯†ç‚¹
                    knowledgeFact.style.display = 'block';
                    knowledgeFact.innerHTML = `<strong>ğŸ’¡ çŸ¥è¯†ç‚¹:</strong> ${gem.question.fact}`;

                    setTimeout(() => {
                        modal.classList.remove('active');
                        overlay.classList.remove('active');

                        if (gameState.lives <= 0) {
                            endGame();
                        }
                    }, 3000);
                };
                answersContainer.appendChild(btn);
            });

            modal.classList.add('active');
            overlay.classList.add('active');
        }

        // æ›´æ–°ç»Ÿè®¡
        function updateStats() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            const accuracy = gameState.totalQuestions > 0
                ? Math.round((gameState.correctAnswers / gameState.totalQuestions) * 100)
                : 0;
            document.getElementById('accuracy').textContent = accuracy;
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            if (!gameState.isPlaying) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            ctx.strokeStyle = 'rgba(118, 75, 162, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // æ›´æ–°ç©å®¶ä½ç½®
            if (gameState.keys['ArrowUp'] || gameState.keys['w']) {
                gameState.player.y = Math.max(gameState.player.size, gameState.player.y - gameState.player.speed);
            }
            if (gameState.keys['ArrowDown'] || gameState.keys['s']) {
                gameState.player.y = Math.min(canvas.height - gameState.player.size, gameState.player.y + gameState.player.speed);
            }
            if (gameState.keys['ArrowLeft'] || gameState.keys['a']) {
                gameState.player.x = Math.max(gameState.player.size, gameState.player.x - gameState.player.speed);
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['d']) {
                gameState.player.x = Math.min(canvas.width - gameState.player.size, gameState.player.x + gameState.player.speed);
            }

            // ç»˜åˆ¶ç©å®¶
            ctx.beginPath();
            ctx.arc(gameState.player.x, gameState.player.y, gameState.player.size, 0, Math.PI * 2);
            ctx.fillStyle = gameState.player.color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // ç»˜åˆ¶ç©å®¶çš„å…‰æ™•æ•ˆæœ
            ctx.beginPath();
            ctx.arc(gameState.player.x, gameState.player.y, gameState.player.size + 5, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(118, 75, 162, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // æ›´æ–°å’Œç»˜åˆ¶å®çŸ³
            gameState.gems = gameState.gems.filter(gem => {
                if (gem.collected) return false;

                gem.update();
                gem.draw();

                // æ£€æŸ¥ç¢°æ’
                if (checkCollision(gameState.player, gem, gameState.player.size + gem.size)) {
                    gem.collected = true;
                    showQuestion(gem);
                    return false;
                }

                return true;
            });

            // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
            gameState.particles = gameState.particles.filter(particle => {
                particle.update();
                particle.draw();
                return particle.life > 0;
            });

            // ç”Ÿæˆæ–°å®çŸ³
            if (gameState.gems.length < 3 && Math.random() < 0.02) {
                createGem();
            }

            requestAnimationFrame(gameLoop);
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('gameStats').style.display = 'flex';

            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.lives = 3;
            gameState.totalQuestions = 0;
            gameState.correctAnswers = 0;

            // åˆ›å»ºåˆå§‹å®çŸ³
            for (let i = 0; i < 3; i++) {
                createGem();
            }

            updateStats();
            gameLoop();
        }

        // ç»“æŸæ¸¸æˆ
        function endGame() {
            gameState.isPlaying = false;
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('gameStats').style.display = 'none';
            document.getElementById('gameOver').classList.add('active');
            document.getElementById('finalScore').textContent = gameState.score;
        }

        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            document.getElementById('gameOver').classList.remove('active');
            gameState.gems = [];
            gameState.particles = [];
            gameState.player.x = canvas.width / 2;
            gameState.player.y = canvas.height / 2;
            startGame();
        }

        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        // èƒŒæ™¯ç²’å­åŠ¨ç”»
        const particlesCanvas = document.getElementById('particlesCanvas');
        const pCtx = particlesCanvas.getContext('2d');
        particlesCanvas.width = window.innerWidth;
        particlesCanvas.height = window.innerHeight;

        const backgroundParticles = [];
        for (let i = 0; i < 50; i++) {
            backgroundParticles.push({
                x: Math.random() * particlesCanvas.width,
                y: Math.random() * particlesCanvas.height,
                size: Math.random() * 3 + 1,
                speedX: (Math.random() - 0.5) * 0.5,
                speedY: (Math.random() - 0.5) * 0.5
            });
        }

        function animateBackground() {
            pCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);

            backgroundParticles.forEach(p => {
                p.x += p.speedX;
                p.y += p.speedY;

                if (p.x < 0) p.x = particlesCanvas.width;
                if (p.x > particlesCanvas.width) p.x = 0;
                if (p.y < 0) p.y = particlesCanvas.height;
                if (p.y > particlesCanvas.height) p.y = 0;

                pCtx.beginPath();
                pCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                pCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                pCtx.fill();
            });

            requestAnimationFrame(animateBackground);
        }

        animateBackground();

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            particlesCanvas.width = window.innerWidth;
            particlesCanvas.height = window.innerHeight;
        });
    </script>
</body>
</html>